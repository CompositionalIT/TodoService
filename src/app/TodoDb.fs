// Edit or remove this or the below line to regenerate on next build
// Hash: b202986a2045ce26dd10dad750680587e3b8ee2f7ac737b75febc226d2c10d20

//////////////////////////////////////////
//
// THIS FILE IS AUTOMATICALLY GENERATED
//
// Facil 2.3.2
//
//////////////////////////////////////////

module TodoDb

#nowarn "49"

open System
open System.ComponentModel
open System.Data
open System.Threading
open Microsoft.Data.SqlClient
open Microsoft.Data.SqlClient.Server
open Facil.Runtime.CSharp
open Facil.Runtime.GeneratedCodeUtils


[<EditorBrowsable(EditorBrowsableState.Never)>]
type InternalUseOnly = private | InternalUseOnly
[<EditorBrowsable(EditorBrowsableState.Never)>]
let internalUseOnlyValue = InternalUseOnly


module TableDtos =


  module ``dbo`` =


    type ``Todo`` =
      {
        ``Id``: Guid
        ``Title``: string
        ``Description``: string option
        ``CreatedDate``: DateTime
        ``CompletedDate``: DateTime option
      }

      static member getPrimaryKey (dto: ``Todo``) =
        dto.``Id``


module Scripts =


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Todo_ById_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Todo_ById
SELECT
  [Id],
  [Title],
  [Description],
  [CreatedDate],
  [CompletedDate]
FROM
  [dbo].[Todo]
WHERE
  [Id] = @id"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    let mutable ``ordinal_Id`` = 0
    let mutable ``ordinal_Title`` = 0
    let mutable ``ordinal_Description`` = 0
    let mutable ``ordinal_CreatedDate`` = 0
    let mutable ``ordinal_CompletedDate`` = 0

    let initOrdinals (reader: SqlDataReader) =
      ``ordinal_Id`` <- reader.GetOrdinal "Id"
      ``ordinal_Title`` <- reader.GetOrdinal "Title"
      ``ordinal_Description`` <- reader.GetOrdinal "Description"
      ``ordinal_CreatedDate`` <- reader.GetOrdinal "CreatedDate"
      ``ordinal_CompletedDate`` <- reader.GetOrdinal "CompletedDate"

    let getItem (reader: SqlDataReader) : TableDtos.dbo.Todo =
      let ``Id`` = reader.GetGuid ``ordinal_Id``
      let ``Title`` = reader.GetString ``ordinal_Title``
      let ``Description`` = if reader.IsDBNull ``ordinal_Description`` then None else reader.GetString ``ordinal_Description`` |> Some
      let ``CreatedDate`` = reader.GetDateTime ``ordinal_CreatedDate``
      let ``CompletedDate`` = if reader.IsDBNull ``ordinal_CompletedDate`` then None else reader.GetDateTime ``ordinal_CompletedDate`` |> Some
      {
        ``Id`` = ``Id``
        ``Title`` = ``Title``
        ``Description`` = ``Description``
        ``CreatedDate`` = ``CreatedDate``
        ``CompletedDate`` = ``CompletedDate``
      }

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryEagerAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteWithSyncRead() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeQueryEager connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.LazyExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQueryLazyAsyncWithSyncRead connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member _.LazyExecute() =
      let sqlParams = getSqlParams ()
      executeQueryLazy connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData

    member _.ExecuteSingleAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeQuerySingleAsync connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecuteSingle() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
      }

    member _.ExecuteSingle() =
      let sqlParams = getSqlParams ()
      executeQuerySingle connStr conn tran configureConn (configureCmd sqlParams) initOrdinals getItem tempTableData


  type ``Todo_ById`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Todo_ById``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Todo_ById``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Todo_ById``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: Guid
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.UniqueIdentifier, Value = ``id``)
        |]
      ``Todo_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Id``: Guid) dto))
        |]
      ``Todo_ById_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Todo_Delete_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Todo_Delete
DELETE FROM [dbo].[Todo]
WHERE
  [Id] = @id"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``Todo_Delete`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Todo_Delete``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Todo_Delete``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Todo_Delete``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: Guid
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.UniqueIdentifier, Value = ``id``)
        |]
      ``Todo_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Id``: Guid) dto))
        |]
      ``Todo_Delete_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Todo_Insert_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Todo_Insert
INSERT INTO [dbo].[Todo]
(
  [Id],
  [Title],
  [Description],
  [CreatedDate],
  [CompletedDate]
)
VALUES
(
  @id,
  @title,
  @description,
  @createdDate,
  @completedDate
)"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``Todo_Insert`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Todo_Insert``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Todo_Insert``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Todo_Insert``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: Guid,
        ``title``: string,
        ``description``: string option,
        ``createdDate``: DateTime,
        ``completedDate``: DateTime option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.UniqueIdentifier, Value = ``id``)
          SqlParameter("title", SqlDbType.NVarChar, Size = 255, Value = ``title``)
          SqlParameter("description", SqlDbType.NVarChar, Size = 255, Value = Option.toDbNull ``description``)
          SqlParameter("createdDate", SqlDbType.DateTime, Value = ``createdDate``)
          SqlParameter("completedDate", SqlDbType.DateTime, Value = Option.toDbNull ``completedDate``)
        |]
      ``Todo_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Id``: Guid) dto))
          SqlParameter("title", SqlDbType.NVarChar, Size = 255, Value = (^a: (member ``Title``: string) dto))
          SqlParameter("description", SqlDbType.NVarChar, Size = 255, Value = Option.toDbNull (^a: (member ``Description``: string option) dto))
          SqlParameter("createdDate", SqlDbType.DateTime, Value = (^a: (member ``CreatedDate``: DateTime) dto))
          SqlParameter("completedDate", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``CompletedDate``: DateTime option) dto))
        |]
      ``Todo_Insert_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Todo_Merge_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Todo_Merge
MERGE [dbo].[Todo]
USING
(
  SELECT
    [Id] = @id,
    [Title] = @title,
    [Description] = @description,
    [CreatedDate] = @createdDate,
    [CompletedDate] = @completedDate
)
AS x
ON
  [Todo].[Id] = x.[Id]

WHEN MATCHED THEN
  UPDATE
  SET
    [Title] = x.[Title],
    [Description] = x.[Description],
    [CreatedDate] = x.[CreatedDate],
    [CompletedDate] = x.[CompletedDate]

WHEN NOT MATCHED THEN
  INSERT
  (
    [Id],
    [Title],
    [Description],
    [CreatedDate],
    [CompletedDate]
  )
  VALUES
  (
    x.[Id],
    x.[Title],
    x.[Description],
    x.[CreatedDate],
    x.[CompletedDate]
  )
;"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``Todo_Merge`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Todo_Merge``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Todo_Merge``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Todo_Merge``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: Guid,
        ``title``: string,
        ``description``: string option,
        ``createdDate``: DateTime,
        ``completedDate``: DateTime option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.UniqueIdentifier, Value = ``id``)
          SqlParameter("title", SqlDbType.NVarChar, Size = 255, Value = ``title``)
          SqlParameter("description", SqlDbType.NVarChar, Size = 255, Value = Option.toDbNull ``description``)
          SqlParameter("createdDate", SqlDbType.DateTime, Value = ``createdDate``)
          SqlParameter("completedDate", SqlDbType.DateTime, Value = Option.toDbNull ``completedDate``)
        |]
      ``Todo_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Id``: Guid) dto))
          SqlParameter("title", SqlDbType.NVarChar, Size = 255, Value = (^a: (member ``Title``: string) dto))
          SqlParameter("description", SqlDbType.NVarChar, Size = 255, Value = Option.toDbNull (^a: (member ``Description``: string option) dto))
          SqlParameter("createdDate", SqlDbType.DateTime, Value = (^a: (member ``CreatedDate``: DateTime) dto))
          SqlParameter("completedDate", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``CompletedDate``: DateTime option) dto))
        |]
      ``Todo_Merge_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  [<EditorBrowsable(EditorBrowsableState.Never)>]
  type ``Todo_Update_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

    let configureCmd sqlParams (cmd: SqlCommand) =
      cmd.CommandText <- """-- Todo_Update
UPDATE
  [dbo].[Todo]
SET
  [Title] = @title,
  [Description] = @description,
  [CreatedDate] = @createdDate,
  [CompletedDate] = @completedDate
WHERE
  [Id] = @id"""
      cmd.Parameters.AddRange sqlParams
      userConfigureCmd cmd

    member _.ExecuteAsync(?cancellationToken) =
      let sqlParams = getSqlParams ()
      executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

    member this.AsyncExecute() =
      async {
        let! ct = Async.CancellationToken
        return! this.ExecuteAsync(ct) |> Async.AwaitTask
      }

    member _.Execute() =
      let sqlParams = getSqlParams ()
      executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


  type ``Todo_Update`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    new() =
      failwith "This constructor is for aiding reflection and type constraints only"
      ``Todo_Update``(null, null, null)

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val connStr = connStr

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val conn = conn

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val tran = tran

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val configureConn : SqlConnection -> unit = ignore with get, set

    [<EditorBrowsable(EditorBrowsableState.Never)>]
    member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

    member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
      this.userConfigureCmd <- configureCommand
      this

    static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
      ``Todo_Update``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

    static member WithConnection(connection, ?transaction) = ``Todo_Update``(null, connection, defaultArg transaction null)

    member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
      match configureConnection with
      | None -> ()
      | Some config -> this.configureConn <- config
      this

    member this.WithParameters
      (
        ``id``: Guid,
        ``title``: string,
        ``description``: string option,
        ``createdDate``: DateTime,
        ``completedDate``: DateTime option
      ) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.UniqueIdentifier, Value = ``id``)
          SqlParameter("title", SqlDbType.NVarChar, Size = 255, Value = ``title``)
          SqlParameter("description", SqlDbType.NVarChar, Size = 255, Value = Option.toDbNull ``description``)
          SqlParameter("createdDate", SqlDbType.DateTime, Value = ``createdDate``)
          SqlParameter("completedDate", SqlDbType.DateTime, Value = Option.toDbNull ``completedDate``)
        |]
      ``Todo_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

    member inline this.WithParameters(dto: ^a) =
      let getSqlParams () =
        [|
          SqlParameter("id", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Id``: Guid) dto))
          SqlParameter("title", SqlDbType.NVarChar, Size = 255, Value = (^a: (member ``Title``: string) dto))
          SqlParameter("description", SqlDbType.NVarChar, Size = 255, Value = Option.toDbNull (^a: (member ``Description``: string option) dto))
          SqlParameter("createdDate", SqlDbType.DateTime, Value = (^a: (member ``CreatedDate``: DateTime) dto))
          SqlParameter("completedDate", SqlDbType.DateTime, Value = Option.toDbNull (^a: (member ``CompletedDate``: DateTime option) dto))
        |]
      ``Todo_Update_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``Commands`` =


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``CompleteTodo_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

        let configureCmd sqlParams (cmd: SqlCommand) =
          cmd.CommandText <- """-- Commands\CompleteTodo.sql
UPDATE dbo.Todo
SET CompletedDate = @Date
WHERE Id = @Id"""
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        member _.ExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          let sqlParams = getSqlParams ()
          executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


      type ``CompleteTodo`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``CompleteTodo``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val tran = tran

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``CompleteTodo``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``CompleteTodo``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``Date``: DateTime,
            ``Id``: Guid
          ) =
          let getSqlParams () =
            [|
              SqlParameter("@Date", SqlDbType.DateTime, Value = ``Date``)
              SqlParameter("@Id", SqlDbType.UniqueIdentifier, Value = ``Id``)
            |]
          ``CompleteTodo_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

        member inline this.WithParameters(dto: ^a) =
          let getSqlParams () =
            [|
              SqlParameter("@Date", SqlDbType.DateTime, Value = (^a: (member ``Date``: DateTime) dto))
              SqlParameter("@Id", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Id``: Guid) dto))
            |]
          ``CompleteTodo_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


      [<EditorBrowsable(EditorBrowsableState.Never)>]
      type ``EditTodo_Executable`` (connStr: string, conn: SqlConnection, configureConn: SqlConnection -> unit, userConfigureCmd: SqlCommand -> unit, getSqlParams: unit -> SqlParameter [], tempTableData: seq<TempTableData>, tran: SqlTransaction) =

        let configureCmd sqlParams (cmd: SqlCommand) =
          cmd.CommandText <- """-- Commands\EditTodo.sql
UPDATE dbo.Todo
SET Title = @Title,
    [Description] = @Description
WHERE Id = @Id"""
          cmd.Parameters.AddRange sqlParams
          userConfigureCmd cmd

        member _.ExecuteAsync(?cancellationToken) =
          let sqlParams = getSqlParams ()
          executeNonQueryAsync connStr conn tran configureConn (configureCmd sqlParams) tempTableData (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member _.Execute() =
          let sqlParams = getSqlParams ()
          executeNonQuery connStr conn tran configureConn (configureCmd sqlParams) tempTableData


      type ``EditTodo`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``EditTodo``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val connStr = connStr

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val conn = conn

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val tran = tran

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``EditTodo``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``EditTodo``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.WithParameters
          (
            ``Title``: string,
            ``Description``: string,
            ``Id``: Guid
          ) =
          let getSqlParams () =
            [|
              SqlParameter("@Title", SqlDbType.NVarChar, Size = 255, Value = ``Title``)
              SqlParameter("@Description", SqlDbType.NVarChar, Size = 255, Value = ``Description``)
              SqlParameter("@Id", SqlDbType.UniqueIdentifier, Value = ``Id``)
            |]
          ``EditTodo_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)

        member inline this.WithParameters(dto: ^a) =
          let getSqlParams () =
            [|
              SqlParameter("@Title", SqlDbType.NVarChar, Size = 255, Value = (^a: (member ``Title``: string) dto))
              SqlParameter("@Description", SqlDbType.NVarChar, Size = 255, Value = (^a: (member ``Description``: string) dto))
              SqlParameter("@Id", SqlDbType.UniqueIdentifier, Value = (^a: (member ``Id``: Guid) dto))
            |]
          ``EditTodo_Executable``(this.connStr, this.conn, this.configureConn, this.userConfigureCmd, getSqlParams, [], this.tran)


  module ``Queries`` =


      type ``GetAllItems`` private (connStr: string, conn: SqlConnection, tran: SqlTransaction) =

        let configureCmd userConfigureCmd (cmd: SqlCommand) =
          cmd.CommandText <- """-- Queries\GetAllItems.sql
SELECT * FROM dbo.Todo"""
          userConfigureCmd cmd

        let mutable ``ordinal_Id`` = 0
        let mutable ``ordinal_Title`` = 0
        let mutable ``ordinal_Description`` = 0
        let mutable ``ordinal_CreatedDate`` = 0
        let mutable ``ordinal_CompletedDate`` = 0

        let initOrdinals (reader: SqlDataReader) =
          ``ordinal_Id`` <- reader.GetOrdinal "Id"
          ``ordinal_Title`` <- reader.GetOrdinal "Title"
          ``ordinal_Description`` <- reader.GetOrdinal "Description"
          ``ordinal_CreatedDate`` <- reader.GetOrdinal "CreatedDate"
          ``ordinal_CompletedDate`` <- reader.GetOrdinal "CompletedDate"

        let getItem (reader: SqlDataReader) : TableDtos.dbo.Todo =
          let ``Id`` = reader.GetGuid ``ordinal_Id``
          let ``Title`` = reader.GetString ``ordinal_Title``
          let ``Description`` = if reader.IsDBNull ``ordinal_Description`` then None else reader.GetString ``ordinal_Description`` |> Some
          let ``CreatedDate`` = reader.GetDateTime ``ordinal_CreatedDate``
          let ``CompletedDate`` = if reader.IsDBNull ``ordinal_CompletedDate`` then None else reader.GetDateTime ``ordinal_CompletedDate`` |> Some
          {
            ``Id`` = ``Id``
            ``Title`` = ``Title``
            ``Description`` = ``Description``
            ``CreatedDate`` = ``CreatedDate``
            ``CompletedDate`` = ``CompletedDate``
          }

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        new() =
          failwith "This constructor is for aiding reflection and type constraints only"
          ``GetAllItems``(null, null, null)

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val configureConn : SqlConnection -> unit = ignore with get, set

        [<EditorBrowsable(EditorBrowsableState.Never)>]
        member val userConfigureCmd : SqlCommand -> unit = ignore with get, set

        member this.ConfigureCommand(configureCommand: SqlCommand -> unit) =
          this.userConfigureCmd <- configureCommand
          this

        static member WithConnection(connectionString, ?configureConnection: SqlConnection -> unit) =
          ``GetAllItems``(connectionString, null, null).ConfigureConnection(?configureConnection=configureConnection)

        static member WithConnection(connection, ?transaction) = ``GetAllItems``(null, connection, defaultArg transaction null)

        member private this.ConfigureConnection(?configureConnection: SqlConnection -> unit) =
          match configureConnection with
          | None -> ()
          | Some config -> this.configureConn <- config
          this

        member this.ExecuteAsync(?cancellationToken) =
          executeQueryEagerAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecute() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryEagerAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteWithSyncRead() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteAsyncWithSyncRead(ct) |> Async.AwaitTask
          }

        member this.Execute() =
          executeQueryEager connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.LazyExecuteAsync(?cancellationToken) =
          executeQueryLazyAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecuteAsyncWithSyncRead(?cancellationToken) =
          executeQueryLazyAsyncWithSyncRead connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.LazyExecute() =
          executeQueryLazy connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []

        member this.ExecuteSingleAsync(?cancellationToken) =
          executeQuerySingleAsync connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem [] (defaultArg cancellationToken CancellationToken.None)

        member this.AsyncExecuteSingle() =
          async {
            let! ct = Async.CancellationToken
            return! this.ExecuteSingleAsync(ct) |> Async.AwaitTask
          }

        member this.ExecuteSingle() =
          executeQuerySingle connStr conn tran this.configureConn (configureCmd this.userConfigureCmd) initOrdinals getItem []
